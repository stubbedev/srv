package traefik

import (
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/stubbedev/srv/internal/config"
	"github.com/stubbedev/srv/internal/constants"
	"github.com/stubbedev/srv/internal/shell"
)

// CheckMkcert verifies mkcert is installed and provides installation instructions if not.
func CheckMkcert() error {
	if !shell.Exists("mkcert") {
		if runtime.GOOS == "darwin" {
			return fmt.Errorf("mkcert is not installed.\n  Install with: %s", constants.MkcertInstallMac)
		}
		return fmt.Errorf("mkcert is not installed.\n  See: %s", constants.MkcertInstallURL)
	}
	return nil
}

// IsCAInstalled checks if the mkcert CA is installed.
func IsCAInstalled() bool {
	output, err := shell.MkcertQuiet("-CAROOT")
	if err != nil {
		return false
	}
	caRoot := strings.TrimSpace(string(output))
	if caRoot == "" {
		return false
	}
	_, err = os.Stat(filepath.Join(caRoot, constants.RootCAFile))
	return err == nil
}

// InstallCA installs the mkcert CA certificate.
func InstallCA() error {
	if !shell.Exists("mkcert") {
		return fmt.Errorf("mkcert is not installed.\n  Install it first: %s", constants.MkcertInstallURL)
	}

	if err := shell.Mkcert("-install"); err != nil {
		return fmt.Errorf("failed to install mkcert CA: %w", err)
	}

	return nil
}

// LocalCertsExist checks if local SSL certificates exist for a site.
func LocalCertsExist(siteName, domain string) bool {
	cfg, err := config.Load()
	if err != nil {
		return false
	}
	certFile := filepath.Join(cfg.SiteCertsDir(siteName), domain+constants.ExtCert)
	keyFile := filepath.Join(cfg.SiteCertsDir(siteName), domain+constants.ExtKey)
	_, certErr := os.Stat(certFile)
	_, keyErr := os.Stat(keyFile)
	return certErr == nil && keyErr == nil
}

// RemoveLocalCerts removes SSL certificates for a specific site.
// Returns an error if removal fails for files that exist.
func RemoveLocalCerts(siteName, domain string) error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}
	certFile := filepath.Join(cfg.SiteCertsDir(siteName), domain+constants.ExtCert)
	keyFile := filepath.Join(cfg.SiteCertsDir(siteName), domain+constants.ExtKey)

	var errs []error
	if err := os.Remove(certFile); err != nil && !os.IsNotExist(err) {
		errs = append(errs, fmt.Errorf("failed to remove cert file: %w", err))
	}
	if err := os.Remove(keyFile); err != nil && !os.IsNotExist(err) {
		errs = append(errs, fmt.Errorf("failed to remove key file: %w", err))
	}

	if len(errs) > 0 {
		return fmt.Errorf("failed to remove certificates: %v", errs)
	}
	return nil
}

// GenerateLocalCert generates an SSL certificate for a specific site using mkcert.
func GenerateLocalCert(siteName, domain string) error {
	if err := CheckMkcert(); err != nil {
		return err
	}

	cfg, err := config.Load()
	if err != nil {
		return err
	}

	certDir := cfg.SiteCertsDir(siteName)
	if err := os.MkdirAll(certDir, constants.DirPermDefault); err != nil {
		return fmt.Errorf("failed to create certs directory: %w", err)
	}

	certFile := filepath.Join(certDir, domain+constants.ExtCert)
	keyFile := filepath.Join(certDir, domain+constants.ExtKey)

	args := []string{
		"-cert-file", certFile,
		"-key-file", keyFile,
		domain,
	}

	if err := shell.Mkcert(args...); err != nil {
		return fmt.Errorf("failed to generate certificate for %s: %w", domain, err)
	}

	return nil
}

// RenewThresholdDays is the number of days before expiry to trigger auto-renewal.
const RenewThresholdDays = constants.CertExpiryWarningDays

// EnsureLocalCert generates an SSL certificate for a site if it doesn't exist
// or if the existing certificate is expired or expiring soon.
// Returns (renewed bool, err error) where renewed indicates if a cert was regenerated.
func EnsureLocalCert(siteName, domain string) (bool, error) {
	if !LocalCertsExist(siteName, domain) {
		return true, GenerateLocalCert(siteName, domain)
	}

	// Check if cert needs renewal
	cert := GetLocalCertInfo(siteName, domain)
	if cert.IsExpired || cert.DaysLeft <= RenewThresholdDays {
		return true, GenerateLocalCert(siteName, domain)
	}

	return false, nil
}

// UpdateDynamicConfig regenerates the Traefik dynamic config with all local domain certs.
// It scans all site directories for certificates.
func UpdateDynamicConfig() error {
	cfg, err := config.Load()
	if err != nil {
		return err
	}

	// Find all certificates across all site directories
	certs, err := scanSiteCertificates(cfg)
	if err != nil {
		return err
	}

	// Build dynamic config
	var content strings.Builder
	content.WriteString("# Dynamic Traefik configuration - generated by srv\n")
	content.WriteString("# Do not edit manually\n")
	content.WriteString("tls:\n")

	if len(certs) == 0 {
		content.WriteString("  certificates: []\n")
	} else {
		content.WriteString("  certificates:\n")
		for _, cert := range certs {
			// Path inside container: /etc/traefik/sites/{siteName}/certs/{domain}.crt
			certPath := fmt.Sprintf("%s/%s/%s/%s%s",
				constants.TraefikContainerSitesPath,
				cert.siteName,
				constants.TraefikContainerCertsSubdir,
				cert.domain,
				constants.ExtCert)
			keyPath := fmt.Sprintf("%s/%s/%s/%s%s",
				constants.TraefikContainerSitesPath,
				cert.siteName,
				constants.TraefikContainerCertsSubdir,
				cert.domain,
				constants.ExtKey)
			content.WriteString(fmt.Sprintf("    - certFile: %s\n", certPath))
			content.WriteString(fmt.Sprintf("      keyFile: %s\n", keyPath))
		}
	}

	dynamicPath := filepath.Join(cfg.TraefikConfDir(), "traefik-dynamic.yml")
	if err := os.WriteFile(dynamicPath, []byte(content.String()), constants.FilePermDefault); err != nil {
		return fmt.Errorf("failed to write dynamic config: %w", err)
	}

	return nil
}

// certEntry represents a certificate file pair for a site.
type certEntry struct {
	siteName string
	domain   string
}

// scanSiteCertificates scans all site directories for certificate files.
// Returns a list of certEntry with siteName and domain for each valid cert/key pair.
func scanSiteCertificates(cfg *config.Config) ([]certEntry, error) {
	var certs []certEntry

	// Scan sites directory
	siteEntries, err := os.ReadDir(cfg.SitesDir)
	if err != nil {
		if os.IsNotExist(err) {
			return certs, nil
		}
		return nil, fmt.Errorf("failed to read sites directory: %w", err)
	}

	for _, siteEntry := range siteEntries {
		if !siteEntry.IsDir() {
			continue
		}
		siteName := siteEntry.Name()
		certDir := cfg.SiteCertsDir(siteName)

		certFiles, err := os.ReadDir(certDir)
		if err != nil {
			continue // No certs dir for this site
		}

		for _, certFile := range certFiles {
			if certFile.IsDir() {
				continue
			}
			name := certFile.Name()
			if strings.HasSuffix(name, constants.ExtCert) {
				domain := strings.TrimSuffix(name, constants.ExtCert)
				keyFile := filepath.Join(certDir, domain+constants.ExtKey)
				if _, err := os.Stat(keyFile); err == nil {
					certs = append(certs, certEntry{siteName: siteName, domain: domain})
				}
			}
		}
	}

	return certs, nil
}

// CertInfo holds certificate expiry information.
type CertInfo struct {
	SiteName  string
	Domain    string
	Exists    bool
	ExpiresAt time.Time
	DaysLeft  int
	IsExpired bool
}

// GetLocalCertInfo returns information about a specific site's SSL certificate.
func GetLocalCertInfo(siteName, domain string) CertInfo {
	cfg, err := config.Load()
	if err != nil {
		return CertInfo{SiteName: siteName, Domain: domain}
	}

	certFile := filepath.Join(cfg.SiteCertsDir(siteName), domain+constants.ExtCert)
	info := parseCertFile(certFile)
	info.SiteName = siteName
	info.Domain = domain
	return info
}

// ListLocalCerts returns information about all local SSL certificates across all sites.
func ListLocalCerts() []CertInfo {
	cfg, err := config.Load()
	if err != nil {
		return nil
	}

	certs, err := scanSiteCertificates(cfg)
	if err != nil {
		return nil
	}

	var certInfos []CertInfo
	for _, cert := range certs {
		certInfos = append(certInfos, GetLocalCertInfo(cert.siteName, cert.domain))
	}

	return certInfos
}

// parseCertFile reads a PEM certificate file and returns expiry info.
// Returns Exists: false if the file doesn't exist or is malformed.
func parseCertFile(certPath string) CertInfo {
	data, err := os.ReadFile(certPath)
	if err != nil {
		return CertInfo{Exists: false}
	}

	block, _ := pem.Decode(data)
	if block == nil {
		// File exists but is not valid PEM - treat as missing/corrupt
		return CertInfo{Exists: false}
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		// PEM decoded but certificate is invalid - treat as missing/corrupt
		return CertInfo{Exists: false}
	}

	now := time.Now()
	daysLeft := int(cert.NotAfter.Sub(now).Hours() / constants.HoursPerDay)

	return CertInfo{
		Exists:    true,
		ExpiresAt: cert.NotAfter,
		DaysLeft:  daysLeft,
		IsExpired: now.After(cert.NotAfter),
	}
}
