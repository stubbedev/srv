package traefik

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/stubbedev/srv/internal/config"
	"github.com/stubbedev/srv/internal/constants"
)

// SiteRouteConfig holds the configuration for a site's Traefik routing.
type SiteRouteConfig struct {
	Name        string // Site name (used for router/service names)
	Domain      string // Domain to route
	ServiceName string // Container name to route to
	Port        int    // Port the service listens on
	IsLocal     bool   // Whether to use local SSL (mkcert) or Let's Encrypt
}

// WriteSiteRouteConfig creates a Traefik file provider config for a site.
// This allows routing to Docker compose services without modifying the project's compose files.
// The config is written to ~/.config/srv/traefik/conf/site-{name}.yml
func WriteSiteRouteConfig(cfg *config.Config, route SiteRouteConfig) error {
	// Build the config using proper types to avoid YAML injection
	type Server struct {
		URL string `yaml:"url"`
	}
	type LoadBalancer struct {
		Servers []Server `yaml:"servers"`
	}
	type Service struct {
		LoadBalancer LoadBalancer `yaml:"loadBalancer"`
	}
	type TLSConfig struct {
		CertResolver string `yaml:"certResolver,omitempty"`
	}
	type Router struct {
		Rule        string     `yaml:"rule"`
		EntryPoints []string   `yaml:"entryPoints"`
		Service     string     `yaml:"service"`
		TLS         *TLSConfig `yaml:"tls,omitempty"`
	}
	type HTTP struct {
		Routers  map[string]Router  `yaml:"routers"`
		Services map[string]Service `yaml:"services"`
	}
	type SiteConfig struct {
		HTTP HTTP `yaml:"http"`
	}

	routerName := constants.SiteConfigPrefix + route.Name
	serviceName := constants.SiteConfigPrefix + route.Name

	// Route to the service via docker network
	// The URL format is http://{container_name}:{port}
	// We use the container name directly since Traefik resolves via Docker network
	serviceURL := fmt.Sprintf("http://%s:%d", route.ServiceName, route.Port)

	router := Router{
		Rule:        fmt.Sprintf("Host(`%s`)", route.Domain),
		EntryPoints: []string{constants.EntryPointWebsecure},
		Service:     serviceName,
	}

	if route.IsLocal {
		// Local SSL uses file provider certificates (no certResolver)
		router.TLS = &TLSConfig{}
	} else {
		// Production uses Let's Encrypt
		router.TLS = &TLSConfig{CertResolver: constants.CertResolverLetsEncrypt}
	}

	siteConfig := SiteConfig{
		HTTP: HTTP{
			Routers: map[string]Router{
				routerName: router,
			},
			Services: map[string]Service{
				serviceName: {
					LoadBalancer: LoadBalancer{
						Servers: []Server{{URL: serviceURL}},
					},
				},
			},
		},
	}

	data, err := yaml.Marshal(&siteConfig)
	if err != nil {
		return fmt.Errorf("failed to marshal site config: %w", err)
	}

	// Add header comment with metadata
	header := fmt.Sprintf(`# Site configuration for %s - generated by srv
# Domain: %s
# Container: %s
# Port: %d
`, route.Name, route.Domain, route.ServiceName, route.Port)

	content := header + string(data)

	siteFile := filepath.Join(cfg.TraefikConfDir(), constants.SiteConfigPrefix+route.Name+constants.ExtYAML)
	return os.WriteFile(siteFile, []byte(content), constants.FilePermDefault)
}

// RemoveSiteRouteConfig removes the Traefik file provider config for a site.
func RemoveSiteRouteConfig(cfg *config.Config, name string) error {
	siteFile := filepath.Join(cfg.TraefikConfDir(), constants.SiteConfigPrefix+name+constants.ExtYAML)
	if err := os.Remove(siteFile); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove site config: %w", err)
	}
	return nil
}

// traefikRouteConfig represents the structure of a Traefik file provider config.
// Used for parsing site and proxy route configs.
type traefikRouteConfig struct {
	HTTP struct {
		Routers map[string]struct {
			Rule string `yaml:"rule"`
		} `yaml:"routers"`
	} `yaml:"http"`
}

// ExtractDomainFromRule extracts the domain from a Traefik Host rule.
// Rule format: Host(`example.com`) or Host(`example.com`, `www.example.com`)
// Returns the first domain found in the rule.
func ExtractDomainFromRule(rule string) string {
	const prefix = "Host(`"
	idx := strings.Index(rule, prefix)
	if idx == -1 {
		return ""
	}
	start := idx + len(prefix)
	end := strings.Index(rule[start:], "`")
	if end == -1 {
		return ""
	}
	return rule[start : start+end]
}

// ReadSiteRouteDomain reads the domain from a site route config file.
func ReadSiteRouteDomain(cfg *config.Config, name string) string {
	siteFile := filepath.Join(cfg.TraefikConfDir(), constants.SiteConfigPrefix+name+constants.ExtYAML)
	data, err := os.ReadFile(siteFile)
	if err != nil {
		return ""
	}

	// Parse the YAML structure
	var config traefikRouteConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return ""
	}

	// Extract domain from first router's rule
	for _, router := range config.HTTP.Routers {
		if domain := ExtractDomainFromRule(router.Rule); domain != "" {
			return domain
		}
	}

	return ""
}
